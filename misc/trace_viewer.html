<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Trace Viewer: Base vs SFT</title>
  <style>
    :root {
      color-scheme: light dark;
      --bg: #0f1117;
      --panel: #161925;
      --text: #e8ecf1;
      --muted: #9aa3b5;
      --accent: #7dcfff;
      --danger: #ff6b6b;
      --success: #2ecc71;
      --border: #222637;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      padding: 20px;
      font-family: "Inter", system-ui, -apple-system, sans-serif;
      background: var(--bg);
      color: var(--text);
    }
    h1 { margin-top: 0; }
    .row { display: flex; gap: 16px; flex-wrap: wrap; }
    .card {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 12px 14px;
    }
    label { font-size: 13px; color: var(--muted); }
    input[type="file"], select {
      margin-top: 6px;
      padding: 6px 8px;
      background: #111421;
      border: 1px solid var(--border);
      color: var(--text);
      border-radius: 6px;
    }
    select { min-width: 260px; }
    .grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
      gap: 16px;
      margin-top: 12px;
    }
    .header-line {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
      margin-bottom: 8px;
    }
    .pill {
      padding: 4px 8px;
      border-radius: 999px;
      font-size: 12px;
      font-weight: 600;
      border: 1px solid var(--border);
      color: var(--muted);
    }
    .pill.success { color: var(--success); border-color: var(--success); }
    .pill.danger { color: var(--danger); border-color: var(--danger); }
    .title { font-weight: 700; }
    details { border: 1px solid var(--border); border-radius: 8px; padding: 8px 10px; margin: 6px 0; background: #111421; }
    summary { cursor: pointer; font-weight: 600; }
    pre {
      white-space: pre-wrap;
      background: #0d1020;
      padding: 8px 10px;
      border-radius: 8px;
      border: 1px solid var(--border);
      overflow-x: auto;
      font-size: 13px;
      line-height: 1.5;
    }
    .muted { color: var(--muted); }
    .flex { display: flex; gap: 8px; flex-wrap: wrap; align-items: center; }
    .small { font-size: 13px; }
    .metrics-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: 12px;
      margin-top: 12px;
    }
    ul { padding-left: 18px; margin: 6px 0 0 0; }
    li { font-size: 13px; line-height: 1.4; }
  </style>
</head>
<body>
  <h1>Model Trace Viewer (Base vs SFT)</h1>

  <div class="row">
    <div class="card">
      <label>Problem ID</label><br />
      <select id="problemSelect" disabled></select>
    </div>
  </div>

  <div id="meta" class="card" style="margin-top:12px; display:none;">
    <div class="flex">
      <div class="title" id="problemText"></div>
    </div>
    <div class="small muted" id="target"></div>
  </div>

  <div class="grid" id="panels" style="display:none;">
    <div class="card" id="basePanel">
      <div class="header-line">
        <span class="title">Base Model</span>
        <span id="baseStatus" class="pill">—</span>
      </div>
      <div class="small muted" id="basePred"></div>
      <div id="baseTree"></div>
    </div>
    <div class="card" id="sftPanel">
      <div class="header-line">
        <span class="title">SFT Model</span>
        <span id="sftStatus" class="pill">—</span>
      </div>
      <div class="small muted" id="sftPred"></div>
      <div id="sftTree"></div>
    </div>
  </div>

  <div id="metricsContainer" class="card" style="margin-top:12px; display:none;">
    <div class="title" style="margin-bottom:8px;">Metrics (averaged over all rollouts)</div>
    <div class="small muted" style="margin-bottom:6px;">Computed from text lengths; response_length used when present.</div>
    <div class="metrics-grid">
      <div>
        <div class="title small">Max children per fork</div>
        <div class="muted small">Averaged across all rollouts</div>
        <ul id="metricWidth"></ul>
      </div>
      <div>
        <div class="title small">Parent + longest descendant chain (avg chars)</div>
        <div class="muted small">(I.e. the critical path length)</div>
        <ul id="metricThroughput"></ul>
      </div>
      <div>
        <div class="title small">Context lengths</div>
        <div class="muted small"> </div>
        <ul id="metricCtx"></ul>
      </div>
    </div>
  </div>

  <div class="card">
    <label>Base JSONL file</label><br />
    <input id="baseFile" type="file" accept=".jsonl,.txt" />
  </div>
  <div class="card">
    <label>SFT JSONL file</label><br />
    <input id="sftFile" type="file" accept=".jsonl,.txt" />
  </div>
  <div class="card">
    <label>Optional: Metrics CSV (any task)</label><br />
    <input id="csvFile" type="file" accept=".csv,.txt" />
    <div class="small muted" style="margin-top:4px;">Loads into metrics panel; also logs metrics to console.</div>
  </div>

  <script>
    const baseInput = document.getElementById('baseFile');
    const sftInput  = document.getElementById('sftFile');
    const csvInput  = document.getElementById('csvFile');
    const problemSelect = document.getElementById('problemSelect');
    const meta = document.getElementById('meta');
    const panels = document.getElementById('panels');

    let baseData = {};
    let sftData = {};
    let csvData = {};

    // ---- tree utilities (recursive) ----
    function buildNestedChildren(node) {
      const kids = [];
      if (Array.isArray(node.fork_trace)) {
        node.fork_trace.forEach((fork) => {
          const forkNode = { text: fork.parent_text || '', response_length: fork.response_length, children: [] };
          if (Array.isArray(fork.child_traces)) {
            fork.child_traces.forEach((child) => {
              forkNode.children.push({
                text: child.full_response || child.answer || '',
                response_length: child.response_length,
                fork_trace: child.fork_trace,
                children: buildNestedChildren(child),
              });
            });
          }
          kids.push(forkNode);
        });
      }
      return kids;
    }

    function buildTreeFromRecord(rec) {
      const root = { text: rec.parent_rollout || '', response_length: rec.response_length, children: [] };
      if (Array.isArray(rec.fork_trace)) {
        rec.fork_trace.forEach((fork) => {
          const forkNode = { text: fork.parent_text || '', response_length: fork.response_length, children: [] };
          if (Array.isArray(fork.child_traces)) {
            fork.child_traces.forEach((child) => {
              forkNode.children.push({
                text: child.full_response || child.answer || '',
                response_length: child.response_length,
                fork_trace: child.fork_trace,
                children: buildNestedChildren(child),
              });
            });
          }
          root.children.push(forkNode);
        });
      }
      return root;
    }

    function walkMetrics(node) {
      let widths = [node.children.length];
      let textLens = [node.text.length];
      let ctxLens = [typeof node.response_length === 'number' ? node.response_length : node.text.length];

      node.children.forEach((c) => {
        const sub = walkMetrics(c);
        widths = widths.concat(sub.widths);
        textLens = textLens.concat(sub.textLens);
        ctxLens = ctxLens.concat(sub.ctxLens);
      });

      return { widths, textLens, ctxLens };
    }

    function maxPathLen(node) {
      if (!node.children.length) return node.text.length;
      let best = 0;
      node.children.forEach((c) => { best = Math.max(best, maxPathLen(c)); });
      return node.text.length + best;
    }

    // helpers
    function median(arr) {
      if (!arr.length) return 0;
      const a = [...arr].sort((x, y) => x - y);
      const mid = Math.floor(a.length / 2);
      return a.length % 2 === 0 ? (a[mid - 1] + a[mid]) / 2 : a[mid];
    }

    function summarizeMetrics(records) {
      const values = Object.values(records);
      if (!values.length) return null;

      const widths = [];
      const pathLens = [];
      const ctxLens = [];

      values.forEach((rec) => {
        const tree = buildTreeFromRecord(rec);
        const walk = walkMetrics(tree);
        widths.push(Math.max(...walk.widths));
        ctxLens.push(...walk.ctxLens);
        pathLens.push(maxPathLen(tree));
      });

      return {
        avgWidth: widths.length ? (widths.reduce((a,b)=>a+b,0)/widths.length).toFixed(2) : '0.00',
        medPath: median(pathLens).toFixed(1),
        medCtx: median(ctxLens).toFixed(1),
      };
    }

    // Simple CSV parser (comma-separated, header row). Returns object keyed by problem_id.
    function parseCsv(text) {
      const lines = text.trim().split(/\r?\n/);
      if (!lines.length) return {};
      const headers = lines[0].split(',').map((h) => h.trim());
      const out = {};
      lines.slice(1).forEach((line, idx) => {
        if (!line.trim()) return;
        const cols = line.split(',');
        const obj = {};
        headers.forEach((h, i) => { obj[h] = cols[i] ?? ''; });
        if (obj.fork_trace) {
          try { obj.fork_trace = JSON.parse(obj.fork_trace); } catch { obj.fork_trace = []; }
        }
        if (obj.response_length) {
          const n = Number(obj.response_length);
          if (!Number.isNaN(n)) obj.response_length = n;
        }
        obj.problem_id = obj.problem_id || `csv_row_${idx}`;
        out[obj.problem_id] = obj;
      });
      return out;
    }

    function parseJsonl(text) {
      const out = {};
      text.split('\n').forEach((line) => {
        const t = line.trim();
        if (!t) return;
        try {
          const obj = JSON.parse(t);
          if (obj.problem_id) out[obj.problem_id] = obj;
        } catch (err) {
          console.warn('Bad line', line, err);
        }
      });
      return out;
    }

    function updateProblemList() {
      const baseIds = new Set(Object.keys(baseData));
      const sftIds  = new Set(Object.keys(sftData));
      const common = [...baseIds].filter((id) => sftIds.has(id)).sort();

      problemSelect.innerHTML = '';
      if (common.length === 0) {
        problemSelect.disabled = true;
        meta.style.display = 'none';
        panels.style.display = 'none';
        return;
      }
      common.forEach((id) => {
        const opt = document.createElement('option');
        opt.value = id;
        opt.textContent = id;
        problemSelect.appendChild(opt);
      });
      problemSelect.disabled = false;
      renderProblem(common[0]);

      // refresh metrics
      const baseMetrics = summarizeMetrics(baseData);
      const sftMetrics  = summarizeMetrics(sftData);
      renderMetrics(baseMetrics, sftMetrics);
    }

    function badge(el, ok) {
      el.className = 'pill ' + (ok ? 'success' : 'danger');
      el.textContent = ok ? 'Correct' : 'Incorrect';
    }

    function renderTree(container, record) {
      container.innerHTML = '';

      function renderNode(node, label) {
        const det = document.createElement('details');
        det.open = label === 'Parent';
        const sum = document.createElement('summary');
        sum.textContent = label;
        det.appendChild(sum);
        const pre = document.createElement('pre');
        pre.textContent = node.text || '<empty>';
        det.appendChild(pre);
        if (node.children && node.children.length) {
          node.children.forEach((c, idx) => {
            det.appendChild(renderNode(c, `Child ${idx + 1}`));
          });
        }
        return det;
      }

      const tree = buildTreeFromRecord(record);
      container.appendChild(renderNode(tree, 'Parent rollout'));
    }

    function renderProblem(pid) {
      const base = baseData[pid];
      const sft  = sftData[pid];
      if (!base || !sft) return;

      meta.style.display = 'block';
      panels.style.display = 'grid';

      document.getElementById('problemText').textContent = base.problem_text || '(no text)';
      document.getElementById('target').textContent = 'Target: ' + (base.target_answer || '');

      const baseStatus = document.getElementById('baseStatus');
      badge(baseStatus, !!base.is_correct);
      document.getElementById('basePred').textContent = 'Prediction: ' + (base.prediction || '<none>');
      renderTree(document.getElementById('baseTree'), base);

      const sftStatus = document.getElementById('sftStatus');
      badge(sftStatus, !!sft.is_correct);
      document.getElementById('sftPred').textContent = 'Prediction: ' + (sft.prediction || '<none>');
      renderTree(document.getElementById('sftTree'), sft);
    }

    problemSelect.addEventListener('change', () => {
      renderProblem(problemSelect.value);
    });

    function handleFile(input, setter) {
      const file = input.files?.[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = (ev) => {
        setter(parseJsonl(ev.target.result));
        updateProblemList();
      };
      reader.readAsText(file);
    }

    baseInput.addEventListener('change', () => handleFile(baseInput, (d) => (baseData = d)));
    sftInput.addEventListener('change',  () => handleFile(sftInput,  (d) => (sftData = d)));
    csvInput.addEventListener('change',  () => {
      const file = csvInput.files?.[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = (ev) => {
        csvData = parseCsv(ev.target.result);
        const csvMetrics = summarizeMetrics(csvData);
        console.log('CSV metrics', csvMetrics);
        renderMetrics(csvMetrics, null);
      };
      reader.readAsText(file);
    });

    // Optional: auto-load default files if present (same directory as this HTML).
    // Defaults: base_math500_rollouts.jsonl and sft_math500_rollouts.jsonl
    // You can override via query params: ?base=...&sft=...
    async function tryAutoLoad() {
      const params = new URLSearchParams(window.location.search);
      const baseUrl = params.get('base') || 'base_math500_rollouts.jsonl';
      const sftUrl  = params.get('sft')  || 'sft_math500_rollouts.jsonl';

      async function fetchMaybe(url) {
        try {
          const res = await fetch(url);
          if (!res.ok) throw new Error(res.statusText);
          const text = await res.text();
          return text;
        } catch (e) {
          return null;
        }
      }

      const [baseText, sftText] = await Promise.all([fetchMaybe(baseUrl), fetchMaybe(sftUrl)]);
      if (baseText) baseData = parseJsonl(baseText);
      if (sftText)  sftData  = parseJsonl(sftText);
      if (baseText || sftText) updateProblemList();
    }

    function renderMetrics(baseMetrics, sftMetrics) {
      const container = document.getElementById('metricsContainer');
      if (!baseMetrics && !sftMetrics) {
        container.style.display = 'none';
        return;
      }
      container.style.display = 'block';

      function renderStat(el, labelBase, labelSft, valBase, valSft) {
        el.innerHTML = '';
        if (valBase !== undefined) {
          const li = document.createElement('li');
          li.textContent = `${labelBase}: ${valBase}`;
          el.appendChild(li);
        }
        if (valSft !== undefined) {
          const li = document.createElement('li');
          li.textContent = `${labelSft}: ${valSft}`;
          el.appendChild(li);
        }
      }

      renderStat(document.getElementById('metricWidth'), 'Base avg max children', 'SFT avg max children', baseMetrics?.avgWidth, sftMetrics?.avgWidth);
      renderStat(document.getElementById('metricThroughput'), 'Base median path len', 'SFT median path len', baseMetrics?.medPath, sftMetrics?.medPath);
      renderStat(document.getElementById('metricCtx'), 'Base median context len', 'SFT median context len', baseMetrics?.medCtx, sftMetrics?.medCtx);
    }

    // Kick off optional autoload (non-blocking if files are absent)
    tryAutoLoad();
  </script>
</body>
</html>

